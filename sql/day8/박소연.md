# 15강 반복계의 공포

## 1. 반복계의 단점

-   성능 DOWN
-   데이터베이스가 SQL을 받을 때 마다 SQL을 파스하는 부분에서 작은 SQL을 여러번 반복하는 반복계에서는 오버헤드가 높아질 수 밖에 없다.
-   반복계는 리소스 사용 효율이 나쁨
-   구문을 튜닝할 수 있는 가능성이 거의 없다.

## 2. 반복계를 빠르게 만드는 방법은 없을까?

-   반복계를 포장계로 다시 작성 => 실제 상황에서 사용할 수 없는 경우가 많음
-   각각의 SQL을 빠르게 수정 => INSERT구문의 경우 고속화가 어려워 튜닝 가능성이 더욱 제한됨
-   다중화 처리 => 데이터를 분할할 수 있는 명확한 키가 없거나, 순서가 중요한 처리, 병렬화했을 때 물리 리소스가 부족하다면 사용할 수 없음
-   결국, 튜닝 선택지가 한정적이며 대대적인 애플리케이션 수정을 각오해야한다.

## 3. 반복계의 장점

-   실행 계획이 단순하면 해당 실행계획에 변동 위험이 거의 없어 안정성을 확보할 수 있다.
-   예상 처리 시간의 정밀도가 높다.
    -   반복계의 처리 시간
    -   ` <처리 시간> = <한 번의 실행 시간> X <실행 횟수>`
-   트랜젝션 제어가 편리

# 16강 SQL에서는 반복을 어떻게 표현할까?

## 1. 포인트는 CASE 식과 원도우 함수

-   상관 서브쿼리로는 어려운 코드를 윈도우 함수를 활용할 수 있다.

## 2. 최대 반복 횟수가 정해진 경우

-   예시 ![image](https://ifh.cc/g/rWNpwN.jpg)

## 3. 반복 횟수가 정해지지 않은 경우

-   포인터 체인을 사용한 인접 리스트 모델
    -   ![image](https://ifh.cc/g/7sops7.jpg)
-   재귀 공통 테이블 식(recursion common table expression)
    -   예시 ![image](https://ifh.cc/g/XcX0W1.jpg)
    -   유연한 코드이지만 재귀 공통 테이블은 비교적 최근에 만들어진 기능이므로 아직 구현되지 않았거나 실행 계획이 최적화되지 않은 DBMS가 있다. => 중첩 집합 모델로 대체 가능

# 17강 바이어스의 공죄

-   SQL이 가진 강력한 도구와 튜닝 방법을 활용하려면 집합지향의 사고방식을 가지는 것이 좋다.

# 18강 기능적 관점으로 구분하는 결합의 종류

## 1. 크로스 결합 - 모든 결합의 모체

-   데카르트 곱
-   가능한 모든 조합을 구하는 연산
-   크로스 결합이 실무에서 사용되지 않는 이유
    -   이러한 결과가 필요한 경우가 없다.
    -   비용이 매우 많이 드는 연산이다.

## 2.내부 결합 - 왜 '내부'라는 말을 사용할까?

-   내부 결합은 '데카르트 곱의 부분 집합'이라는 의미
-   내부결합과 상관 서브쿼리 중 상관 서브쿼리는 결과 레코드 수만큼 상관 서브쿼리를 실행하기 때문에 기본적으로는 결합을 사용하는 것이좋음

## 3.외부 결합 = 왜 '외부'라는 말을 사용할까?

-   외부 결합은 '데카르트 곱의 부분 집합이 아니다'는 의미이나 데이터 상태에 따라 경우에 따라서는 데카르트 곱의 부분 집합이 되기도 한다.
-   외부 결합 종류
    -   왼쪽 외부 결합
    -   오른쪽 외부 결합
    -   완전 외부 결합

## 4. 외부 결합과 내부 결합의 차이

-   크로스 결합, 내부 결합, 외부 결합의 관계![image](https://ifh.cc/g/lRkRdj.jpg)

## 5. 자기 결합 - '자기'란 누구일까?

-   같은 테이블(또는 같은 뷰)를 사용해 결합
-   크로스 결합의 결과 레코드 수는, 결합 대산이 되는 테이블의 레코드 수를 곱

# 19강 결합 알고리즘과 성능

-   옵티마이저가 선택가능한 결합 알고리즘
    -   Nested Loops: 각종 결합 알고리즘의 기본이됨
    -   Hash
    -   Sort Merge
    -   결합 알고리즘 - https://insight-bgh.tistory.com/79

## 1. Nested Loops

-   중첩 반복을 사용하는 알고리즘
-   작동
    -   결합 대상 테이블에서 레코드를 하나씩 스캔(구동 테이블 또는 외부 테이블) -> 구동 테이블의 레코드 하나마다 내부 테이블의 레코드를 하나씩 스캔해서 결합 조건애 맞으면 리턴 -> 이를 구동 테이블의 모든 레코드에 반복
-   한번의 단계에서 처리하는 레코드 수가 적으므로 Hash 또는 Sort Merge에 비해 메모리 소비가 적음
-   구동 테이블이 작을 수록 성능이 좋아짐, 구동 테이블의 인덱스를 활용하여 성능 UP => 구동 테이블이 작은 'Nested Loops' + '내부 테이블의 결합 키에 인덱스' 이 조합이 SLQ 튜닝의 기본
-   이중 반복의 외측과 내측의 반복 처리가 비대칭
-   단점: 절대적인 양이 맣으면 반복이 많이 일어나 지연 발생

## 2. Hash

-입력에 대해 어느 정도 유일성과 균일성을 가진 값을 출력하는 함수

-   해시 테이블은 DBMS의 워킹 메모리에 저장됨
-   해시의 특징
    -   결합 테이블로부터 해시 테이블을 만들어서 활용하므로, Nested Loops에 비해 메모리를 크게 소모
    -   메모리가 부족하면 저장소를 이용해 지연 발생
    -   츨력되는 해시값은 입력값의 순서를 알지 못하므로, 등치 결합에서만 사용 가능
-   Nested Loops가 효율적으로 작동하지 않는 경우의 차선책

## 3. Sort Merge

-   Merge 또는 Merge Join이라고 부르기도함, 결합 대상 테이블들을 각각 결합 키로 정렬하고 일치하는 키를 찾으면 결합
-   특징
    -   메모리가 많이 소모 => 지연 발생
    -   부등호를 사용한 결합에도 사용가능(<> 제외)
    -   한쪽 테이블을 모두 스캔한 시점에 결합을 완료
-   테이블 정렬을 생략할 경우 사용을 고려

## 4. 의도하지 않은 크로스 결합

-   의도하지 않게 크로스 결합이 나타나는 경우가 있다. ‘삼각 결합’이라 부르는 패턴이다.
-   불필요한 결합 조건을 추가해서 크로스 결합을 회피
