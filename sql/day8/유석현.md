# 14. 반복문 의존증
- SQL에는 반복문이 없다
- 비즈니스 로직은 호스트 언어(절차형 언어)에서 반복 처리를 구현하는 것이 일반적이다
- 이렇게 하면 SQL에 반복 기능이 없다고 해도 상관없다

# 15. 반복계의 공포
- 반복계로 구현한 코드는 포장계로 구현한 코드에 성능적으로 이길 수가 없다
- 반복계의 처리시간은 포장계에 비해 데이터 양에 따라 선형으로 증가한다
- 반복계는 반복 1회마다의 처리를 굉장히 단순화합니다.
- 따라서 리소스를 분산해서 병령 처리하는 최적화가 안 된다
- DBMS의 버전이 오를수록 옵티마이저는 보다 효율적으로 실행 계획을 세우며, 데이터에 고속으로 접근할 수 있는 아키텍처를 구현한다
- 반복계는 단지 느리기만 한 것이 아니라 느린 구문을 튜닝할 수 있는 가능성도 거의 없다고 할 수 있다
- 반복계를 빠르게 만드는 방법(반복계를 포장계로 다시 작성, 각각의 SQL을 빠르게 수정, 다중화 처리)
- 실행 계획이 단순하다는 것은 해당 실행 계획에 변동 변동 위험이 거의 없다라는 것을 나타낸다
- 포장계는 SQL 구문이 복잡한 만큼 실행 계획의 변동 가능성이 굉장히 크다
- 실행 계획이 단순하고 성능이 안정적이라는 것은 예상 처리 시간의 정밀도가 높다는 장점을 가져온다

# 16. SQL에서는 반복을 어떻게 표현할까?
- SQL에서 반복을 대신하는 수단은 바로 CASE 식과 윈도우 함수이다


# 17. 바이어스의 공죄
- 심리학에는 '망치'라는 도구만을 가지고 있는 사람에게는 모든 문제가 못으로 보인다'라는 말이 있다
- 반복은 너무나도 강력한 망치이다

# 18. 기능적 관점으로 구분하는 결합의 종류
- 결합들 중 기능적인 관점으로 분류한 것이 크로스 결합, 내부 결합, 외부 결합이다
- 크로스 결합은 실무에서 사용할 기회가 거의 없다
- 비용이 매우 많이 드는 연산이기 때문이다
- 내부 결합은 가장 많이 사용되는 조합 중 하나이다
- 내부는 '데카르트 곱의 부분 집합'이라는 의미이다
- 가장 쉽게 내부 결합을 구하는 알고리즘을 만든다면 크로스 결합으로 결과를 내고 결합 조건으로 필터링하는 것이다
- 외부 결합은 내부 결합과 함계 자주 사용되는 결합이다
- '외부'는 '데카르트 곱의 부분 집합이 아니다'라는 의미이다
- 외부 결합은 왼쪽, 오른쪽 완전 외부 결합으로 나뉜다
- 외부 결합 결과가 크로스 결합 결과의 부분 집합이 아닌 이유는 외부 결합이 마스터 테이블의 정보를 모두 보존하고자 NULL을 생성하기 떄문이다
- 자기 결합은 문자 그대로 자기 자신과 결합하는 연산이다

# 19. 결합 알고리즘과 성능
- 옵티마이저가 선택 가능한 결합 알고리즘은 Nested Loops, Hash, Sort Merge 세 가지가 있다
- 옵티마이저가 어떤 알고리즘을 선택할지 여부는 데이터 크기 또는 결합 키의 분산이라는 요인에 의존한다
- 그중 가장 빈번하게 볼 수 있는 알고리즘은 Nested Loops로, 각종 결합 알고리즘의 기본이 되는 알고리즘이다
- 구동 테이블이 작을수록 Nested Loops의 성능이 좋아진다
- 만약 내부 테이블의 결합 키 필드에 인덱스가 존재한다면, 해당 인덱스를 통해 DBMS는 내부 테이블을 완전히 순환하지 않아도 된다
- 작은 테이블에서 해시 테이블을 만드는 이유는, 해시 테이블은 DBMS의 워킹 메모리에 저장되므로 조금이라도 작은 것이 효율적이기 때문이다
- Hash는 Nested Loops가 효율적으로 작동하지 않는 경우의 차선책이다
- Nested Loops가 비효율적인 경우, Hash 사용 외에 또 다른 선택지로 Sort Merge라는 알고리즘도 있다
- 테이블 정렬을 생략할 수 있는 경우에는 Sort Merge를 고려해볼만하지만, 그 이외의 경우에는 Nested Loops와 Hash를 우선적으로 고려해야 한다
- '삼각 결합'이라고 부르는 패턴에서 의도치 않게 크로스 결합이 나타나는 경우가 있다

# 20. 결합이 느리다면
- Nested Loops는 OLTP에 적합하고 Hash와 Sort Merge는 대규모 테이블을 결합할 때 적합하다
- MySQL은 결합 알고리즘 자체가 Nested Loops 밖에 없으므로 따로 선택의 여지가 없다
- 사용자가 실행 계획을 제어할 때는 위험을 충분히 검토하고, 시스테므이 미래 상황도 예측해서 적절한 실행 계획을 선택해야 한다
- SQL의 성능의 변동 위험을 줄이려면 되도록 결합을 피해햐 한다
