# 14. 반복문 의존증
- SQL에는 반복문이 없다
- 비즈니스 로직은 호스트 언어(절차형 언어)에서 반복 처리를 구현하는 것이 일반적이다
- 이렇게 하면 SQL에 반복 기능이 없다고 해도 상관없다

# 15. 반복계의 공포
- 반복계로 구현한 코드는 포장계로 구현한 코드에 성능적으로 이길 수가 없다
- 반복계의 처리시간은 포장계에 비해 데이터 양에 따라 선형으로 증가한다
- 반복계는 반복 1회마다의 처리를 굉장히 단순화합니다.
- 따라서 리소스를 분산해서 병령 처리하는 최적화가 안 된다
- DBMS의 버전이 오를수록 옵티마이저는 보다 효율적으로 실행 계획을 세우며, 데이터에 고속으로 접근할 수 있는 아키텍처를 구현한다
- 반복계는 단지 느리기만 한 것이 아니라 느린 구문을 튜닝할 수 있는 가능성도 거의 없다고 할 수 있다
- 반복계를 빠르게 만드는 방법(반복계를 포장계로 다시 작성, 각각의 SQL을 빠르게 수정, 다중화 처리)
- 실행 계획이 단순하다는 것은 해당 실행 계획에 변동 변동 위험이 거의 없다라는 것을 나타낸다
- 포장계는 SQL 구문이 복잡한 만큼 실행 계획의 변동 가능성이 굉장히 크다
- 실행 계획이 단순하고 성능이 안정적이라는 것은 예상 처리 시간의 정밀도가 높다는 장점을 가져온다

# 16. SQL에서는 반복을 어떻게 표현할까?
- SQL에서 반복을 대신하는 수단은 바로 CASE 식과 윈도우 함수이다


# 17. 바이어스의 공죄
- 심리학에는 '망치'라는 도구만을 가지고 있는 사람에게는 모든 문제가 못으로 보인다'라는 말이 있다
- 반복은 너무나도 강력한 망치이다

# 18. 기능적 관점으로 구분하는 결합의 종류
- 결합들 중 기능적인 관점으로 분류한 것이 크로스 결합, 내부 결합, 외부 결합이다
- 크로스 결합은 실무에서 사용할 기회가 거의 없다
- 비용이 매우 많이 드는 연산이기 때문이다
- 내부 결합은 가장 많이 사용되는 조합 중 하나이다
- 내부는 '데카르트 곱의 부분 집합'이라는 의미이다
- 가장 쉽게 내부 결합을 구하는 알고리즘을 만든다면 크로스 결합으로 결과를 내고 결합 조건으로 필터링하는 것이다
- 외부 결합은 내부 결합과 함계 자주 사용되는 결합이다
- '외부'는 '데카르트 곱의 부분 집합이 아니다'라는 의미이다
- 외부 결합은 왼쪽, 오른쪽 완전 외부 결합으로 나뉜다
- 외부 결합 결과가 크로스 결합 결과의 부분 집합이 아닌 이유는 외부 결합이 마스터 테이블의 정보를 모두 보존하고자 NULL을 생성하기 떄문이다
- 자기 결합은 문자 그대로 자기 자신과 결합하는 연산이다

# 19. 결합 알고리즘과 성능
- 옵티마이저가 선택 가능한 결합 알고리즘은 Nested Loops, Hash, Sort Merge 세 가지가 있다
- 옵티마이저가 어떤 알고리즘을 선택할지 여부는 데이터 크기 또는 결합 키의 분산이라는 요인에 의존한다
- 그중 가장 빈번하게 볼 수 있는 알고리즘은 Nested Loops로, 각종 결합 알고리즘의 기본이 되는 알고리즘이다
- 구동 테이블이 Nested Loops의 
