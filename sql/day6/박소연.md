# 1강 DBMS 아키텍처 개요

-   DBMS가 다양한 처리를 수행

## 1. 쿼리 평가 엔진

-   사용자로부터 입력받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정 -> 실행 계획
-   계획을 세우고 실행하는 DBMS의 핵심 기능을 담당하는 모듈

## 2. 버퍼 매니저

-   버퍼: 특별한 용도로 사용하는 메모리 영역
-   DBMS의 버퍼를 관리, 디스크 용량 매니저와 연동되어 작동

## 3. 디스크 용량 매니저

-   데이터를 어디에, 어떻게 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어

## 4. 트랜잭션 매니저와 락 매니저

-   트랜잭션의 정합성을 유지하도록 관리하고 필요시에는 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 것이 트랜잭션 매니저와 락 매니저의 역할

## 5. 리커버리 매니저

-   데이터를 정기적으로 백업하고, 문제가 일어났을 때 복구하는 역할

# 2강 DBMS와 버퍼

-   데이터를 버퍼에 어떤식으로 확보할지가 중요

## 1. 공짜 밥은 존재할까?

-   기억장치 계층
    ![기억장치의 계층](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2Ffa09c6ca-04b3-44f3-bdad-7cba5a185c6a%2F20220213_232304165.jpg)

## 2. DBMS와 기억장치의 관계

-   DBMS와 기억장치는 밀접한 관계임
-   하드디스크(HDD)
    -   DBMS가 데이터를 저장하는 대부분 매체(저장소)
    -   2차 기억장치
-   메모리
    -   가격이 비쌈
    -   용량이 작음
-   버퍼를 활용한 속도 향상
    -   버퍼 / 캐시
    -   메모리와 디스크는 대충 수십만 배에서 수백만 배의 성능 차이가 있음
    -   디스크 접근을 줄인다면 큰 폭의 성능 향상 가능
    -   버퍼 매니저가 데이터베이스의 성능에 굉장히 중요한 영향을 끼친다.

## 3. 메모리 위에 있는 두 개의 버퍼

-   데이터 캐시: 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역

-   로그 버퍼 - 갱신 처리(INSERT, DELETE, UPDATE, MERGE) - 갱신처리는 비동기로 이루어짐, 디스크에 변경사항이 반영되는 동안 대기가 발생하기 때문에
    ![image](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2F2d23bfee-24ee-4e67-82c9-5d0aeba613ec%2F20220213_232547923.jpg)

## 4. 메모리의 성질이 초래하는 트레이브오프

-   휘발성: DBMS를 껐다 켜면 버퍼 위의 모든 데이터 삭제
-   데이터 캐시는 날아가도 다시 불러오면 되지만 로그 버퍼의 데이터는 심각
-   휘발성의 문제점 해결: DBMS는 커밋 시점에 반드시 갱신 정보를 로크 파일에 쓰도록 함, 커밋 시 디스크에 동기 접근이 일어남
-   디스크에 동기 처리를 하면 데이터 정합성을 높일 수 있지만 성능은 저하됨

## 5. 시스템 특성에 따른 트레이드오프

-   데이터 캐시와 로그 버퍼의 크기
    -   데이터 베이스는 검색을 중시한 매모리 배분이 기본  
        ![image](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2F37ba2965-c20b-4c52-aa31-8407672d4677%2F20220213_232555498.jpg) -많은 DBMS가 물리 메모리에 여유가 된다면, 데이터 캐시를 되도록 많이 할당할것을 추천함
-   데이터 베이스가 어디에 기반을 두고 리소스를 분배하고 있는지 파악하는게 중요(로그 버퍼가 크게 잡혀있다면 갱신처리, 데이터 캐시가 크게 잡혀있다면 검색 처리가 중심)

## 6. 추가적인 메모리 영역 '워킹 메모리'

-   워킹 메모리(working memory): 정렬 또는 해시 관련 처리에 사용되는 작업용 영역
-   각 DBMS에서 워킹 메모리를 부르는 명칭과 설정
    |DBMS|명칭|매개변수|기본값|  
     |---|---|---|---|
    |Oracle 11g R2|PGA(Program Global Area)|PGA_AGGREGATE_TARGET|10MB or SGA 크기의 20% 중 큰 것|
    |PostgreSQL 9.3|워크 버퍼|work_mem|8MB|
    |MySQL 5.7|정렬 버퍼|sort_buffer_size|256KB|
-   메모리가 부족한 경우 저장소를 사용하는 임시적인 영역을 가지고 있으며 저장소 위에 있으므로 접근 속도가 느림
    -   Oracle: 임시 테이블 스페이스(TEMP Tablespace)
    -   Microsoft SQL Server: TEMPDB
    -   POstgreSQL: 일시 영영(pgsql_tmp)
-   DBMS는 메모리 부족 현상이 발생해도 작업중단 없이 끝까지 처리하려 노력한다는 것을 알 수 있다.

# 3강 DBMS와 실행 계획

## 1. 권한 이양의 죄악

-   비절차적인 RDB는 모든일을 사용자가 아니라 시스템에게 맡겼고 사용자가 하는 일은 대상을 기술하는 것으로 축소되있는데 이로 인해 성능 문제로 고생하여 내부 절차를 들여다 봐야한다.

## 2. 데이터에 접근하는 방법은 어떻게 결정할까?

-   쿼리 평가 모듈은 추가로 파서 또는 옵티마이저와 같은 여러개의 서브 모듈로 구성됨
-   DBMS의 쿼리 처리 흐름
    ![image](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2Fa1f7c854-f280-43b2-9eda-ad6eb1272a1b%2F20220213_232618663.jpg)
-   파서(parser): 구문 분석을 하는 역할을 수행하며 사용자가 압룍헌 SQL구문을 정형적인 형식으로 변환하여 DBMS 내부에서 후속 처리가 효율화 되도록 한다.
-   옵티마이저(optimizer, 최적화)
    -   데이터 접근법(실행 계획)을 최적화 함(DBMS의 두뇌의 핵심)
    -   인덱스 유무, 데이터 분산 또는 편향 정도, DBMS 내부 매개변수 등의 조건을 고려해서, 선택 가능한 많은 실행 계획을 작성하고, 이들의 비용을 연산하고, 가장 낮은 비용을 가진 실행 계획을 선택한다.
-   카탈로그 매니저(catalog manager)
    -   옵티마이저가 실행 계획을 세울 때 옵티마이저에 중요한 정보(카탈로그)를 제공함
    -   카탈로그: DBMS의 내부 정보를 모아놀은 테이블로, 테이블 또는 인덱스의 통계정보가 저장되어 있음(통계 정보)
-   플랜 평가(plan evaluation): 실행 계획을 세운 뒤 그것을 받아 최적의 실행결과를 선택하는 것이며 하나의 실행 계획을 선택하면, 이후에 DBMS는 실행 계획을 절차적인 코드로 변환하고 데이터 접근을 수행한다.

## 3. 옵티마이저와 통계 정보

-   카탈로그 매니저가 관리하는 통계 정보에 대해서 데이터베이스 엔지니어가 신경써줘야한다.
-   플랜 선택을 옵티마이저에게 맡기는 경우, 최적의 플랜이 선택되지 않는 경우가 있으며 이는 통계 정보가 부족한 경우가 대표적 이유다.
-   통계 정보 (구현에 따라 차이 있음)
    -   각 테이블의 레코드 수
    -   각 테이블의 필드 수와 필드의 크기
    -   필드의 카디널리티 값의 개수
    -   필드값의 히스토그램(어떤 값이 얼마나 분포되어 있는가)
    -   필드 내부에 있는 NULL 수
    -   인덱스 정보
-   카탈로그 정보가 갱신되지 않는다면, 옵티마이저는 오래된 정보를 바탕으로 실행 계획을 세우게 되어 잘못된 계획을 세울 수 밖에 없음

## 4. 최적의 실행 계획이 작성되게 하려면

-   테이블의 데이터가 많이 바뀌면 카탈로그의 통계 정보도 함께 갱신해야한다.(기본 상식)
-   통계 정보 갱신은 대상 테이블 또는 인덱스의 크기와 수에 따라서 실행 비용이 굉장히 높은 작업이지만 DBMS가 최적의 플랜을 선택하려면 필요한 조건이다.
-   대표적인 DBMS의 통계 정보 갱신 명령어
    ![image](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2Fa88c14ee-f406-42b6-9399-c10dd3e8b817%2F20220213_232403678.jpg)

# 4강 실행 계획이 SQL 구문의 성능을 결정

-   SQL 문이 복잡한 경우 최적의 접근 방법을 선택하지 못하는 경우도 있음

## 1. 실행 계획 확인 방법

-   실행 계획을 확인하는 명령어
    ![image](https://velog.velcdn.com/images%2Fyangsijun528%2Fpost%2F854651ca-b866-4a5e-8394-161cc6b24c7c%2F20220214_124245400.jpg)

    [참고](https://cheese10yun.github.io/mysql-explian/)

-   결합 알고리즘
    -   Nested Loops(중첩 반봅): 한쪽 테이블을 읽으면서 레코드 하나마다 결합조건에 맞는 레코드를 다른 쪽 테이블에서 찾는 방식
    -   Sort Merge: 결합키로 레코드를 정렬하고, 순차적으로 두개의 테이블을 결합하는 방식, 워킹 메모리 사용
    -   Hash: 결합 키 값을 해시값으로 맵핑하는 방법, 해시테이블을 만들어야하므로, 작업용 메모리 영역을 필요로함.

## 5. 실행 계획의 중요성

-   수동으로 실행 계획을 변경할 수 있다.(Oracle, MySQL등에서 힌트 구를 사용하여 SQL 구문에서 옵티마이저에게 강제적으로 명령할 수 있다.)
-   [LRU 알고리즘](https://doublesprogramming.tistory.com/254)

# 6강 SELECT 구문

## 1. SELECT 구와 FROM 구

-   SELECT 구: 테이블이 갖고 있는 필드라면 쉼표로 구분하여 지정
-   FROM 구: 데이터를 선택할 대상 테이블 지정

## 2. WHERE 구

-   WHERE 구: 조건 지정(and, or, in, null검색)
-   SELECT 구문의 기능은 절차 지향형 언어에서의 '함수'와 같다는 것을 알 수 있다.(2차원 테이블을 입력하여 2차원 테이블을 출력한다.)

## 3. GROUP BY 구

-   집계연산을 SQL구문으로 함
-   그룹을 나누어 여러 집계가 가능
    ![image](https://ifh.cc/g/WzwB2S.jpg)

## 4. HAVING 구

-   집합에 조건을 지정함

## 5. ORDER BY 구

-   레코드 정렬 조건

## 6. 뷰와 서브쿼리

-   뷰: SELECT 구문을 저장(테이블의 모습을 한 SELECT 구문)
-   서브쿼리: SQL은 서브쿼리부터 순서대로 실행

# 7강 조건 분기, 집합 연산, 윈도우 함수, 갱신

## 1. SQL과 조건 분기

-   식을 기준으로 SQL의 조건을 분기함
-   CASE: 식이므로 SELECT, WHERE, GROUP BY, HAVING, ORDER BY 구 어디서나 사용가능

## 2. SQL의 집합 연산

-   UNION으로 합집합(합): 두개의 테이블을 하나의 테이블로 합친 결과를 반환하며 기본으로 중복 제거를 하므로 UNION ALL 과같이 ALL 옵션을 사용할 수 있음
-   INTERSECT로 교집합(교차): 양쪽 테이블에 공통으로 존재하는 레코드 출력
-   EXCEPT로 차집합(제외): UNION, INTERSECT와 다르게 순서에 영향이 있음. 차(-)를 의미하기 때문

## 3. 윈도우 함수

-   테이블을 조건으로 자르지만 집약하지 않음, 출력 결과의 레코드 수가 입력되는 테이블의 레코드 수와 같다.
-   ex) SELECT address, COUNT(\*) OVER(PARTITION BY address) FROM Address;
-   COUNT, SUM 등의 일반 함수, RANK, ROW_NUMBER 등의 순서 함수를 윈도우 함수로 사용 가능
-   [보충](https://seoyuun22.tistory.com/entry/SQLPART2-05-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-SQL-200%EC%A0%9C-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-041-046)

## 4. 트랜잭션과 갱신

-   SQL의 갱신 작업
    -   삽입(insert): 데이터 삽입
    ```
    INSERT INTO [테이블 이름] ([필드1], [필드2], [필드3] ......) VALUES ([값1], [값2], [값3].....);
    ```
    -   제거(delete): 데이터 제거, 일부 레코드 제거 가능
    ```
    DELETE FROM [테이블 이름];
    ```
    -   갱신(update): 데이터 갱신, 일부 레코드만 갱신 가능
    ```
    UPDATE [테이블 이름] SET [필드 이름] = [식];
    ```
