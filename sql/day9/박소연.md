# 21강 서브쿼리가 일으키는 폐해

## 1. 서브쿼리의 문제점

-   연산비용 추가: 반복적으로 SELECT 구문을 실행하여 비용이 추가
-   데이터 I/O 비용 발생: 연산 결과를 DBMS 저장소에 저장하면 접근 속도가 많이 떨어지게 됨
-   최적화를 받을 수 없음: 옵티만이저가 쿼리를 해석하기 위한 정보를 얻을 수 없다.

## 2. 서브쿼리 의존증

-   가독성이 떨어짐
-   대부분 일시적인 영역(메모리 또는 디스크)에 확보되므로 오버헤드가 생긴다.
-   인덱스 또는 제약 정보를 가지지 않아 최적화를 못함
-   결합을 할 시 비용이 높아지고 실행 계획 변동 리스크가 발생
-   같은 테이블을 두번이상 스캔 할 수 있음.
-   SQL 튜닝에서 가장 중요한 부분은 I/O 줄이기!

## 3. 장기적 관점에서의 리스크 관리

-   결합, 상관 서브쿼리 사용시 불안정 요소
    -   결합 알고리즘의 변동 리스크: 대략적으로 레코드 수에 따라 결합 알고리즘을 옵티마이저가 결정하는데 적은 경우 Nested Loops가, 큰 테이블을 결합하는 경우에는 Sort Merge 또는 Hash가 선택되기 쉽다. 따라서 나중에 테이블이 커지면서 변동 리스크가 발생
    -   환경 요인에 의한 지연 리스크(인덱스, 매모리, 매개변수 등)
-   실행계획이 단순할수록 성능이 안정적이다.
-   엔지니어는 기능(결과)뿐만 아니라 비기능적인 부분(성능)도 보장할 책임이 있다.

# 22강 서브쿼리 사용이 더 나은 경우

-   사전에 결합 레코드 수를 압축한다. 근데 실제 개발에서는 테이블의 레코드 수 뿐만 아니라 하드웨어, 미들웨어, 선택되는 결합 알고리즘 등의 요소를 모두 포함하여 고려함

# 23강 레코드에 순번 붙이기

## 1. 기본 키가 한 개의 필드일 경우

-   윈도우 함수 ROW_NUMBER를 사용
-   상관 서브쿼리를 사용
-   윈도우 함수를 사용하는 것이 테이블 스캔 횟수가 적고 인덱스 온리 스캔을 사용하여 테이블 직접 접근을 회피하기 때문에 성능적으로 더 좋다.

## 2. 기본 키가 여러 개의 필드로 구성되는 경우

-   윈도우 함수 ROW_NUMBER를 사용 시 ORDER BY에 필드를 추가
-   상관 쿼리를 사용 시 다중 필드 비교를 사용(복합적인 필드를 하나의 값으로 연결하고 한꺼번에 비교하는 기능)

## 3. 그룹마다 순번능 붙이는 경우

-   윈도우 함수 PARTITION BY 사용
-   상관 쿼리 사용

## 4. 갱신에서 순번을 매기는 방법

-   윈도우 함수: 순번 할당 쿼리를 SET구에 넣고 ROW_NUMBER를 쓸 경우 서브쿼리를 함께 사용
-   상관 쿼리를 사용

# 24강 레코드에 순번 붙이기 응용

## 1. 중앙값 구하기

-   집합 지향적 방법: 테이블을 상위 집합과 하위 집합으로 분할하고 그 공통 부분을 검색하는 방법
-   절차 지향적 방법 1
    -   양쪽에서부터 세기 -> RANK 또는 DENSE_RANK함수는 비슷하지만 정확한 가운데 값이 아닐 수 있으므로 ROW_NUMBER 함수를 이용해야 연속성과 유일성을 갖도록 할 수 있다.
    -   ORDER BY 의 정렬 키에 기본키도 포함해야함
-   절차 지향적 방법 2: 2 _ ROW_NUMBER() - COUNT(_)

## 2. 순번을 사용한 테이블 분할

-   단절 구간 찾기
    -   집합 지향적 방법 - 집합의 경계선
        -   -> (N1.num + 1) < MIN(N2.num)을 베이스로 부합하는 경우 단절을 의미한다. 이 방법은 자기 결합을 하고 그로 인해 비용이 올라가며 실행 계획 변동 위험을 안게 된다.
    -   절차 지향적 방법 - '다음 레코드'와 비교
        -   -> 현재 레코드와 다음 레코드의 숫자 차이를 비교하고 차이가 1이 아니라면 사이에 비어있는 숫자가 있다.는 위와 비슷하지만 윈도우 함수를 사용하여 결합을 피할 수 있다.

## 3. 테이블에 존재하는 시퀀스 구하기

-   집합 지향적 방법 - 다시, 집합의 경계선: MAX/MIN 함수를 사용해서 시퀀스의 경계를 직접적으로 구할 수 있다.
-   절차 지향향 방법 - 다시 '다음 레코드 하나'와 비교

## [레코드 순서를 응용한 예제 참고](https://dlearner.tistory.com/13?category=824584)

# 25강 시퀀스 객체. IDENTITY 필드, 채번 테이블

-   최대한 사용 X, 한다면 시퀀스 객체

## 1. 시퀀스 객체

-   스키마 내부에 존재하는 객체 중 하나이며 create구문으로 정의
-   시퀀스 객체를 사용한 레코드 INSERT 구문

```
INSERT INTO HogeTb1 VALUES(NEXT VALUE FOR nextval, 'a', 'b', ...);
```

-   시퀀스 객체의 문제점
    -   시퀀스 객체가 생성하는 순번은 기본적으로 유일성, 연속성, 순서성의 특성을 가짐, 그래서 어떤 사용자가 시퀀스 객체를 사용한다면 다른 사용자의 접근을 블록하는 배타 제어를 수행한다. 결국 동시에 여러 사용자가 접근할 경우 락 충돌로 인해 성능이 저하
    -   연속성 또는 순서성을 사용하지 않아도 되는 상황이라면 CACHE 와 NOORDER를 채택해서 시퀀스 객체의 성능을 개선 가능
    -   접근이 집중되는 물리영역인 핫스팟 또는 핫블록이 발생, INSERT를 반복해서 대량의 레코드를 생성하는 경우 발생

## 2. IDENTITY 필드

-자동 순번 필드이며 테이블의 필드로 정의하고, 테이블에 INSERT가 발생할 때마다 자동으로 순번을 붙여주는 기능 -> 음.. 결론은 사용하지 마라...!
