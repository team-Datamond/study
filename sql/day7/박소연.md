# 7강 조건 분기, 집합 연산, 윈도우 함수, 갱신

## 1. SQL과 조건 분기

-   식을 기준으로 SQL의 조건을 분기함
-   CASE: 식이므로 SELECT, WHERE, GROUP BY, HAVING, ORDER BY 구 어디서나 사용가능

## 2. SQL의 집합 연산

-   UNION으로 합집합(합): 두개의 테이블을 하나의 테이블로 합친 결과를 반환하며 기본으로 중복 제거를 하므로 UNION ALL 과같이 ALL 옵션을 사용할 수 있음
-   INTERSECT로 교집합(교차): 양쪽 테이블에 공통으로 존재하는 레코드 출력
-   EXCEPT로 차집합(제외): UNION, INTERSECT와 다르게 순서에 영향이 있음. 차(-)를 의미하기 때문

## 3. 윈도우 함수

-   테이블을 조건으로 자르지만 집약하지 않음, 출력 결과의 레코드 수가 입력되는 테이블의 레코드 수와 같다.
-   ex) SELECT address, COUNT(\*) OVER(PARTITION BY address) FROM Address;
-   COUNT, SUM 등의 일반 함수, RANK, ROW_NUMBER 등의 순서 함수를 윈도우 함수로 사용 가능
-   [보충](https://seoyuun22.tistory.com/entry/SQLPART2-05-%EC%B4%88%EB%B3%B4%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-SQL-200%EC%A0%9C-%EB%AC%B8%EC%A0%9C%ED%92%80%EC%9D%B4-041-046)

## 4. 트랜잭션과 갱신

-   SQL의 갱신 작업
    -   삽입(insert): 데이터 삽입
    ```
    INSERT INTO [테이블 이름] ([필드1], [필드2], [필드3] ......) VALUES ([값1], [값2], [값3].....);
    ```
    -   제거(delete): 데이터 제거, 일부 레코드 제거 가능
    ```
    DELETE FROM [테이블 이름];
    ```
    -   갱신(update): 데이터 갱신, 일부 레코드만 갱신 가능
    ```
    UPDATE [테이블 이름] SET [필드 이름] = [식];
    ```

# 8강 UNION을 사용한 쓸데없이 긴 표현

-   UNION을 사용한 조건분기는 외부적으로 하나의 SQL 구문을 실행하는 것처럼 보이지만, 내부적으로는 여러개의 SELECT 구문을 실행하는 실행계획으로 해석되기 때문에 테이블 접근횟수가 많아져 성능적인 측면에서 큰 단점을 가진다.

## 1. UNION을 사용한 조건 분기와 관련된 간단한 예제

-   UNION을 사용했을 때의 실행 계획문제: UNION 사용 시 테이블 접근 횟수가 늘어나고 테이블 풀 스캔을 하므로 읽어들이는 비용도 테이블의 크기에 따라 선형으로 증가한다.
-   정확한 판단이 없는 UNION 사용 회피를 권장

## 2. WHERE 구에서 조건 분기를 하는 사람은 초보자

## 3. SELECT 구를 사용한 조건 분기의 실행 계획

-   SELECT 구로 조건분기를 하면 최적화할 수 있다.
-   기존![기존](https://ifh.cc/g/GRorAN.jpg)![사진](https://ifh.cc/g/BaCboc.jpg)
-   SELECT 구문에서 CASE식을 사용한 조건 분기![사진](https://ifh.cc/g/MKltgL.jpg)![사진](https://ifh.cc/g/TCN9gA.jpg)
-   테이블 접근이 줄어들고 가독성도 좋아짐

# 9강 집계와 조건 분기

## 1. 집계 대상으로 조건 분기

## 2. 집약 결과로 조건 분기

## 3. 집계 대상으로 조건 분기

-   CASE문을 사용하여 구문을 간결하고 테이블 접근을 줄여 성능을 올릴 수 있다.

# 10강 그래도 UNION이 필요한 경우

## 1. UNION을 사용할 수밖에 없는 경우

-   머지 대상이 되는 SELECT 구문들에서 사용하는 테이블이 다른 경우(여러개의 테이블에서 검색한 결과를 머지하는 경우)

## 2. UNION을 사용하는 것이 성능적으로 더 좋은 경우

-   인덱스와 관련
    -   UNION을 사용하여 인덱스를 사용하면 테이블의 레코드 수가 많을 수록 성능차이가 더 많이 나게되며 테이블 풀 스캔보다 빠른 접근속도를 기대할 수 있다.
-   OR을 사용한 방법
    -   테이블 크기와 검색 조건에 따른 선택 비율(레코드 히트율)에 따라 답이 달라짐
    -   테이블이 크고, WHERE 조건으로 선택되는 레코드의 수가 충분히 작다면 UNION이 더 빠름
-   IN을 사용한 방법
    -   OR과 IN은 성능적인 문제가 같다.

# 11강 절차 지향형과 선언형

## 1. 구문 기반과 식 기반

-   SQL 구문의 각 부분(SELECT, FROM, WHERE, GROUP BY, HAVING, ORDER BY)에 작성하는 것은 모두 식.

## 2. 선언형의 세계로 도약

-   절차 지향향에서 선언형으로 도약하기

## 마치며

-   SQL의 성능은 저장소의 I/O를 얼마나 감소시킬 수 있을지가 열쇠
-   UNION에서 조건 분기를 표현한다면 "내가 지금 쓸데없이 길게 쓰고 있는 것은 아닐까?"라는 것을 항상 의식할 것
-   IN 또는 CASE 식으로 조건 분기를 표현할 수 있다면, 테이블에 스캔을 크게 감소시킬 가능성이 있음
-   이를 위해서라도, 구문에서 식으로의 패러다임 전환을 연습
-   UNION과 무조건 동치인 것은 IN을 사용한 쿼리이다.(UNION과 IN은 짝들을 전부 평가하고 CASE식은 단락평가를 수행하기 때문에)

# 12강 집약

-   집약 함수 (aggregate function): 여러개의 레코드를 한개의 레코드로 집약
    -   COUNT
    -   SUM
    -   AVG
    -   MAX
    -   MIN

## 1. 여러 개의 레코드를 한 개의 레코드로 집약

-   CASE 식과 GROUP BY 응용
    ![사진](https://ifh.cc/g/bp47ta.jpg)
-   실행 계획: NonAggTbl을 모두 스캔하고 GROUP BY로 집약
    ![사진](https://ifh.cc/g/gH8jW1.jpg)
-   집약, 해시, 정렬
    -   해시 알고리즘 사용: GROUP BY 구에 지정되어 있는 필드를 해시 함수를 사용해 해시키로 변환하고, 같은 해시 키를 가진 그룹을 모아 집약함
    -   정렬을 사용한 방법보다 빠르며 유일성이 높을 수록 효율적임
    -   연산 대상 레코드 수가 많은 GROUP BY 구(또는 집약 함수)를 사용하는 SQL에서는 충분한 성능 검증을 실행해줘야 한다.

## 2. 합쳐서 하나

-   HAVING 절을 사용하여 여러개의 레코드로 한개의 범위를 커버

# 13강 자르기

## 1. 자르기와 파티션

-   GROUP BY 구의 키로 자르기 가능
-   파티션: 서로 중복되는 요소를 가지지 않는 부분 집합
-   자르기에 기준이 되는 키를 GROUP BY 구와 SELECT 구 또는 CASE식 모두에 입력

## 2. PARTITION BY 구를 사용한 자르기

-   윈도우 함수 'PARTITION BY 구'
-   예시![사진](https://ifh.cc/g/lyPjPP.jpg)

## 마치며

-   GROUP BY 구 또는 원도우 함수의 PARTITION BY 구는 집합을 자를 때 사용
-   GROUP BY 구 또는 원도우 함수는 내부적으로 해시 또는 정렬 처리를 진행
-   해시 또는 정렬은 메모리를 많이 사용해 만약 메모리가 부족하면 일시 영역으로 저장소를 사용해 성능 문제를 일으킴
-   GROUP BY 구 또는 윈도우 함수와 CASE 식을 함께 사용하면 굉장히 다양한 것을 표현할 수 있음
