# 31. 집합 연산
- SQL에서는 SELECT 명령의 실행 결과를 하나의 집합으로 다룰 수 있다
- UNION 키워드를 사용한다

```sql
SELECT * FROM sample_1
UNION
SELECT * FROM sample_2
```

- UNION을 이용하면 여러 개의 SELECT 명령을 하나로 묶을 수 있다
- 이때 각각의 SELECT 명령의 열의 내용(열 개수, 자료형)은 서로 일치해야 한다
- 다만 전체 데이터를 반환하는 애스터리스크(\*)를 쓰지 않고, 열을 따로 지정하여 각 SELECT 명령에서 집합의 요소가 될 데이터를 서로 맞춰주면 UNION으로 실행할 수 있는 쿼리가 된다

```sql
SELECT a FROM sample_1
UNION
SELECT b FROM sample_2
UNION
SELECT age FROM sample_3
```

- SELECT 명령들을 UNION으로 묶을 때 나열 순서는 합집합의 결과에 영향을 주지 않는다
- UNION으로 SELECT 명령을 연결하는 경우, 가장 마지막 SELECT 명령에 대해서만 ORDER BY 구를 지정할 수 있다
- 또한 합집합의 결과를 정렬하는 것이기 때문에 SELECT 명령에서 열 이름이 서로 일치한다면 문제가 없겠지만 반드시 그렇다는 보장이 없으므로, 이런 경우 서로 동일하게 별명을 붙여 정렬할 수 있다

```sql
SELECT a AS c FROM sample_1
UNION
SELECT b AS c FROM sample_2 ORDER BY c
```
- UNION은 합집합을 구하는 것이므로 두 개의 집합에서 겹치는 부분은 공통 요소가 된다
- 중복을 제거하지 않고 여러 개의 SELECT 명령의 결과를 그냥 합치고 싶을 경우에는 UNION ALL을 사용하면 된다
- UNION에서는 이미 존재하는 값인지를 검사하는 처리가 필요한 만큼, UNION ALL 쪽이 성능적으로는 유리할 경우가 있다

<hr>

# 32. 테이블 결합
- 테이블의 집합 연산에서는 세로(행) 방향으로 데이터가 늘어나거나 줄어드는 계산을 했다
- 하지만 결합에서는 가로(열) 방향으로 데이터가 늘어나는 계산이 된다
- 여러 개로 나뉜 데이터를 하나로 묶어 결과를 내는 방법이 테이블 결합이다
- 곱집합은 두 개의 집합을 곱하는 연산 방법으로 '적집합' 또는 '카티전곱'이라고도 불린다
- SELECT 명령의 FROM 구에 테이블을 두 개 지정하면 이들은 곱집합으로 계산된다

```sql
SELECT * FROM sample_1, sample_2;
```
- 테이블을 교차 결합하는 경우는 드물다
- 즉, 결합 방법으로는 교차결합보다 내부결합이 자주 사용된다
- 교차결합으로 계산된 곱집합에서 원하는 조합을 검색하는 것을 '내부결합'이라 부른다

```sql
SELECT * FROM sample_1, sample_2 WHERE sample_1.id = sample_2.id
```
- 위는 구식 방법이고 요즘은 'INNER JOIN'이라는 키워드를 지정해 내부 결합을 한다

```
SELECT * FROM sample_1 INNER JOIN sample_2 ON sample_1.id = sample_2.id
```
- 다른 테이블의 기본키를 참조하는 열을 외부키라고 한다
- 결합 방법은 크게 내부결합과 외부결합의 두 가지로 구분된다
- 외부결합은 '어느 한 쪽에만 존재하는 데이터행을 어떻게 다룰지'를 변경할 수 있는 결합 방법이다
- 방향에 따라 LEFT JOIN, RIGHT JOIN으로 나뉜다

```sql
SELECT a.age, b.name FROM sample_1 a LEFT JOIN sample_2 b ON a.id = b.id;
```

- 현재는 별다른 장점이 없는 구식 결합방법은 사용하지 않는다

<hr>

# 33. 관계형 모델
- 관계형 모델의 기본적인 요소는 릴레이션이다
- 합집합(UNION)
- 차집합(EXCEPT)
- 교집합(INTERSECT)
- 곱집합(CROSS JOIN)
- 선택(WHERE 조건 지정)
- 투영(SELECT 열명 지정)
- 결합(JOIN)

<hr>

# 34. 데이터베이스 설계
- 데이터베이스를 설게한다는 것은 데이터베이스의 스키마 내에 테이블, 인덱스, 뷰 등의 데이터베이스 객체를 정의하는 것을 말한다
- 스키마 내에 정의한다는 뜻에서 '스키마 설계'라 불리기도 한다
- 테이블 정의서는 DESC 명령에 따라 표시되는 결과를 그대로 옮겨적은 것이라 봐도 무방하다
- 실제 SQL 명령에 지정하는 이름을 '물리명'이라 하며 테이블의 설계상 이름은 '논리명'이라 한다
- 열의 자료형, 문자열의 고정길이 가변길이를 지정해야 한다
- 큰 용량을 담을 열일 경우 LOB(Large Object) 형을 사용할 수 있는데, 인덱스를 지정할 수 없다는 제약이 있다
- 기본키 제약을 거는 경우 주의해야 한다
- 테이블을 설계할 때 테이블 간의 관계를 명확히 하기 위해 설계도를 작성하는 경우가 있다
- ER다이어그램은 이런 경우에 널리 쓰이는 도식이다
- ER의 E는 개체를 뜻하는 'Entity'의 약자이며 R은 'Relationship'의 약자이다

<hr>

# 35. 정규화
- 정규화란 데이터베이스의 테이블을 규정된 올바른 형태로 개선해나가는 것이다
- 정규화에서는 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼는다
- 이는 '하나의 데이터는 한 곳에 있어야 한다'는 규칙에 근거한다

<hr>

# 36. 트랜잭션
- 데이터베이스는 트랜잭션이라는 기능을 제공한다
- INSERT나 UPDATE 명령으로 데이터를 추가, 갱신할 때도 트랜잭션 기능을 사용하지만 지금까지 특별히 의식할 필요는 없었다
- 이는 자동 커밋이라 불리는 기능이 동작했기 때문이다
- 여러 개의 INSERT 명령이 실행되다가 마지막 INSERT 명령에서 에러가 발생했다고 치면, 앞서 실행한 몇 개의 INSERT 명령에 의해 추가된 데이터를 삭제하는 처리가 필요하다
- 트랙잭션을 사용하면 에러가 발생해도 트랜잭션을 롤백해서 종료할 수 있다
- 롤백하면 트랜잭션 내에서 행해진 모든 변경사항을 없었던 것으로 할 수 있다
- 아무런 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료하는데, 이때 커밋을 사용한다
- 트랜잭션을 사용해서 데이터를 추가할 때는 자동커밋을 꺼야한다
- INSERT, UPDATE, DELETE가 처리될 때마다 트랜잭션은 암묵적으로 자동커밋 상태로 되어 있기 때문이다
- 자동커밋을 끄기 위해서는 명시적으로 트랜잭션의 시작을 선언해야 한다
- 트랜잭션을 시작할 때는 START TRANSACTION 명령을 사용한다
- 앞서 언급한 것처럼 트랜잭션을 종료하기 위해서는 변경된 내용을 적용한 후에 종료하는 '커밋'과 적용하지 않고 종료하는 '롤백'의 두 가지 방식이 있다
- 커밋할 때는 COMMIT 명령을, 롤백할 때는 ROLLBACK 명령을 사용한다
- 트랜잭션 내에서 실행된 SQL 명령은 임시 데이터 영역에서 수행되다가 COMMIT 명령을 내리면 임시 데이터 영역에서 정식 데이터 영역으로 변경이 적용된다고 생각하면 된다
- ROLLBACK 명령을 내리면 임시 데이터 영역에서의 처리는 버려진다
- 하나의 명령에 트랜잭션을 걸어 실행하는 것은 별로 의미가 없다
- 세트로 실행하고 싶은 SQL 명령을 트랜잭션 내에서 
