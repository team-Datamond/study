### 31강 집합 연산

    ex) SELECT * FROM sample71_a
        UNION
        SELECT * FROM sample71_b;

    - 이때 두 개의 SELECT 명령을 하나의 명령으로 합치는 만큼, 세미콜론(;)은 맨 나눚ㅇ에 붙인다는 점에 주의하여야 한다.
    - 각 SELECT 명령의 실행결과(집합)를 합집합(UNION)으로 계산하여 최종적으로 결과를 반환한다.

    - UNION을 사용할 때 ORDERz BY를 지정할 때는 마지막 SELECT 명령에만 지정하도록 한다.

    UNION의 기본동작은 ALL이 아닌 DISTINCT라는 점이 다르다.

### 32강 테이블 결합

# 곱집합

    ex) X = {A, B, C} Y = {1, 2, 3}
    곱집합 = {A, 1} {A, 2} {A, 3}
           {B, 1} {B, 2} {B, 3}
           {C, 1} {C, 2} {C, 3}

# 교차결합

    ex) SELECT * FROM sample72_x, sample72_y;

    행으로 결합됨

    UNION 연결과 결합 연결의 차이
    - UNION으로 합집합을 구했을 경우에는 세로 방향으로 더해진다.
    - FROM구로 테이블을 결합할 경우에는 가로 방향으로 더해진다.

# 내부결합

    - 참조할 테이블의 기본키와 동일한 이름과 자료형으로 열을 만들어서 행을 연결한다.

    - INNER JOIN으로 내부결합하기
      - ex) SELECT 상품.상품명, 재고수.재고수
              FROM 상품 INNER JOIN 재고수
                ON 상품.상품코드 = 재고수.상품코드
              WHERE 상품.상품분류 = '식료품';
    - 외부키 : 다른 테이블의 기본키를 참조하는 열이 외부키가 된다.
    - 자기결합(Self Join) : 자기결합은 테이블에 별명을 붙일 수 있는 기능을 이용해 같은 테이블끼리 결합하는 것을말한다.

# 외부결합

    - '어느 한 쪽에만 존재하는 데이터행을 어떻게 다룰지'를 변경할 수 있는 결합 방법이다.

### 33강 관계형 모델

# 릴레이션은 테이블을 말한다!

    - 속성(attribute) = 열
    - 튜플(tuple) = 행
    - flffpdltus(relation) = 테이블

    # 관계대수 : 릴레이션에 대한 연산이 집합의 대한 연상에 대응된다는 이론
      - 하나 이상의 관계를 바탕으로 연산한다.
      - 연산한 결과, 반환되는 것 또한 관계이다.
      - 연산을 중첩 구조로 실행해도 상관없다.

    # 합집합
     - 릴레이션끼리의 덧셈(UNION)
    # 차집합
     - 릴레이션끼리의 뺄셈(EXCEPT)
    # 교집합
     - 릴레이션끼리의 공통부분(교집합 INTERSECT)
    # 곱집합
     - 릴레이션끼리의 대전표를 조합하는 연산(FROM 구에 복수의 테이블을 지정한 경우 - CROSS JOIN)
    # 선택
     - 선택(selection)은 튜플의 추출(WHERE 구에 조건을 지정해 데이터를 검색)
    # 투영
     - 속성의 추출(SELECT 구에 결과로 반환할 열을 지정하는 것)
    # 결합
     - 릴레이션끼리 교차결합해 계산된 곱집합에서 결합조건을 만족하는 튜플을 추출하는 연산(내부결합)

### 34강 데이터베이스 설계

# 데이터베이스를 설계한다는 것은 데이터베이스의 스키마 내에 테이블, 인덱스, 뷰 등의 데이터베이스 객체를 정의하는 것

- 테이블을 설계할 때는 테이블 이름이나 열 이름을 지정하는데, 하나의 테이블에 대해 두 개의 이름을 지정할 때 도 있다.
  하나는 데이터베이스에서 사용될 이름, 실제로는 CREATE TABLE에 지정하는 이름을 말하며 '물리명'이라 부른다.
  또 하나는 '논리명'이라는 것으로 테이블의 '설계상 이름'에 해당한다.

물리명 - 데이터베이스 시스템 규칙에 따라 길이에 제한이 있거나 공백문자를 사용할 수 없는 등의 제약이 따른다.
ex) 물리명: item_master 논리명: 상품 마스터

# 물리명은 CREATE TABLE에 지정하는 테이블 이름이나 열 이름이다!

# 논리명은 설꼐상의 실제로 부를 때 사용하는 이름이다!

# 자료형

# 고정길이와 가변길이

    - VARCHAR 형으로 지정할 수 잇는 최대 크기가 크지 않기 때문에 LOB 'Large Object'형을 사용할 수 있다.
    - LOB는 큰 데이터를 다루는 자료형이지만 인덱스를 지정할 수 없다는 제약이 있다.

# 기본키

    - 테이블을 작성할 때 기본키로 지정할 열이 생각나지 않는 경우에 자동증가 열을 사용해서 기본키로 지정하면 간단하게 해결할 수 있다.
    MySQL의 경우 열을 정의할 때 AUTO_INCREMENT로 지정한 열은 PRIMARY KEY 또는 UNIQUE로 유일성을 지정해야 한다.

# ER다이어그램

    엔티티 : 개체는 테이블 또는 뷰를 말한다.
    ER다이어그램에서 개체는 사각형으로 표기한다.
    사각형의 상단에는 개체 이름을 적고 사각형 안에는 개체의 속성을 표기한다.
     - 속성 : 테이블의 열
    열 이름은 주로 논리명으로 표기한다.

### 35강 정규화

# 정규화

    - 테이블을 올바른 형태로 변경하고 분할하는 것

    # 정규화는 단계적으로 실시한다.
     1. 제1정규화
      - 관계형 데이터베이스의 테이블에는 하나의 셀에 하나의 값만 저장할 수 있다는 제약이 있다.
      * 반복되는 데이터를 가로(열 방향)가 아닌 세로(행 방향)로 늘리는 것이 제1정규화의 제1단계이다!
      제1정규화에서는 중복을 제거하는 테이블의 분할로 이루어진다.
      제1정규화에서는 테이블 분할과 기본키 지정이 이루어진다!

     2. 제2정규형
      - 데이터가 중복하는 부분을 찾아내어 테이블로 분할해 나간다.
      - 이때 기본키에 의해 특정되는 열과 그렇지 않은 열로 나누는 것으로 정규화가 이루어진다.
      - 부분 함수종속성을 찾아내서 테이블을 분할하는 것이 제2정규화이다.
      * 함수종속성 : 키 값을 이용해 데이터를 특정지을 수 있는 것

     3. 제3정규형
      - 이 또한 중복하는 부분을 찾아내어 테이블을 분할하는 수법
      - 제2정규화의 경우에는 기본키에 중복이 없는지를 조사
      - 제3정규화에서는 기본키 이외의 부분에서 중복이 없는지를 조사한다.

# 정규화의 목적

- 중복하거나 반복되는 부분을 찾아내서 테이블을 분할하고 기본키를 작성해 사용하는 것을 기본 개념으로 삼는다.
- '하나의 데이터는 한 곳에 있어야 한다'는 규칙에 근거한다.

### 36강 트랜잭션

# 트랜잭션

- 롤백(rollback): 트랜잭션 내에서 행해진 모든 변경사항을 없었던 것으로 한다.
- 커밋(commit): 트랜잭션 내에서 아무 에러가 발생하지 않는다면 변경사항을 적용하고 트랜잭션을 종료한다.

트랜잭션 시작시 명령어: START TRANSACTION

- 트랜잭션을 사용해서 처리하는 것으로 간단히 데이터를 관리할 수 있다!
- 세트로 실행하고 싶은 SQL 명령은 트랜잭션 내에서 실행한다!
